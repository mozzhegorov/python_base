import simple_draw as sd

rainbow_colors = [sd.COLOR_RED, sd.COLOR_ORANGE, sd.COLOR_YELLOW, sd.COLOR_GREEN,
                  sd.COLOR_CYAN, sd.COLOR_BLUE, sd.COLOR_PURPLE]


def draw_rainbow(x, y, radius, color_offset):
    # TODO: используйте срезы, чтобы склеить 2 половины rainbow_colors.
    #  [1,2,3, (режем) 4,5,6]     - режем в нужном месте
    #  [4,5,6, (клеем) 1,2,3]     - склеиваем половины поменяв местами.
    #   Ответ: не понимаю. Зачем это?
    #   Была так сказать ошибочка в основном теле программы. В offset писалась инкрементированная переменная,
    #   сейчас поставил просто контанту 1, и теперь в каждом цикле рисуется сдвинутая на 1 радуга. Вроде согласно ТЗ.

    # TODO: Ответ.
    #  Возможно 2 варианта.
    #  1. color_offset есть, и он показывает насколько сдвинуть цвета в радуге. Извне можно контролировать какой сейчас
    #     цвет будет первым;
    #       for color in rainbow_colors[color_offset:] + rainbow_colors[:color_offset].
    #  2. color_offset отсутствует. Ф-ция изменяет порядок в rainbow_colors при каждом запуске, сдвигая на 1 цвет.
    #     Указать с какого цвета начинать снаружи нельзя. Цикл в этом случае не нужен т.к. итерация только 1.
    #       rainbow_colors.append(rainbow_colors[0])
    #       rainbow_colors.pop(0)
    #  .
    #  Преимущество первого метода: он не имеет состояния. Поэтому мы можем вызвать 2 (или 100500) радуг одновременно.
    #  Преимущество второго - не нужно следить за счетчиком, вызываем и каждый раз получаем следующий набор цветов.
    #  ОТВЕТ: Недоастаток первого метода также в том, что нужно отдельно контролировать offset, так как если
    #  поставить обычный инкремент, то радуга пройдет только 1 цикл (как сейчас). С другой стороны тогда у нас
    #  переменная не будет
    #  улетать в большие значения. Это вообще критично?

    # TODO: Да, эта проблема по хорошему будет сопутствовать все функции, которые занимаются анимацией.
    #  Подробнее написал в 04_painting.py.

    # for _ in range(color_offset):
    #     rainbow_colors.append(rainbow_colors[0])
    #     rainbow_colors.pop(0)

    for color in rainbow_colors[color_offset:] + rainbow_colors[:color_offset]:
        radius += 4
        sd.circle(sd.get_point(x, y), radius, color, 4)

#  Пусть функция отрисовки радуги рисует радугу начиная с указанного в параметре номера цвета.
#  Мы добавим параметр "color_offset", который будет определяеть, начиная с какого цвета рисовать радугу.
#  Допустим color_offset=0, тогда радуга: красный, оранжевый, желает, ..., феолетовый;
#           color_offset=1, тогда радуга: оранжевый, желтый,..., феолетовый, красный (циклический сдвиг на 1 цвет);
#           color_offset=2, тогда радуга: желтый, ..., феолетовый, красный, оранжевый (циклический сдвиг на 1 цвет);
#  .
#  Нам нужно, чтобы был метод draw_rainbow(), который рисует всю радугу. Целиком. Метод принимает следующие
#  параметры:
#   1. x, y - где рисовать радугу;
#   2. radius - радиус минимального кольца цвета;
#   3. color_offset - начиная с какого цвета рисовать радугу.
#  .
#  Пример вызова метода:
#       draw_rainbow(x=100, y=500, radius=50, color_offset=0)   # красный,оранжевый,...,феолетовый;
#       draw_rainbow(x=100, y=500, radius=50, color_offset=1)   # оранжевый,..., феолетовый, красный
#       draw_rainbow(x=100, y=500, radius=50, color_offset=6)   # феолетовый, красный, оранжевый,...
