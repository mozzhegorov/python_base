# -*- coding: utf-8 -*-

# Подсчитать статистику по буквам в романе Война и Мир.
# Входные параметры: файл для сканирования
# Статистику считать только для букв алфавита (см функцию .isalpha() для строк)
#
# Вывести на консоль упорядоченную статистику в виде
# +---------+----------+
# |  буква  | частота  |
# +---------+----------+
# |    А    |   77777  |
# |    Б    |   55555  |
# |   ...   |   .....  |
# |    a    |   33333  |
# |    б    |   11111  |
# |   ...   |   .....  |
# +---------+----------+
# |  итого  | 9999999  |
# +---------+----------+
#
# Упорядочивание по частоте - по убыванию. Ширину таблицы подберите по своему вкусу
# Требования к коду: он должен быть готовым к расширению функциональности. Делать сразу на классах.
import zipfile
from operator import itemgetter
from collections import defaultdict


class TextStat:

    def __init__(self, file_name):
        self.stat = defaultdict(int)
        self.file_name = file_name

    def unzip_file(self):
        zfile = zipfile.ZipFile(self.file_name, 'r')
        #  почему бы сразу не взять последний файл в списке, если он там есть?
        #  Мы в цикле распаковываем все файлы, а по итогу запоминаем только последний.
        self.file_name = zfile.namelist()[-1]
        zfile.extract(self.file_name)

    def get_file_stat(self):
        if self.file_name.endswith('.zip'):
            self.unzip_file()
        with open(self.file_name, 'r', encoding='cp1251') as file:
            for line in file:
                self.get_line_stat(line=line)
        return self.stat

    def get_line_stat(self, line):
        for char in line:
            if char.isalpha():
                self.stat[char] += 1
        return self.stat

    def sorting(self):
        return sorted(self.stat.items())

    def print_stat(self):
        total_letters = 0
        # TODO: как можно сделать запись более читабельнной. Используем простые строки + символ "\n".
        print('+---------+----------+\n'
              '|  буква  | частота  |\n'
              '+---------+----------+')

        for pair in self.sorting():
            print(f'|{pair[0]:^9}|{pair[1]:^10}|')
            total_letters += pair[1]

        # TODO: здесь можно так же сделать, сразу будет понятно, что это footer таблицы
        print(f'''+---------+----------+
|  итого  |{total_letters:^10}|
+---------+----------+''')


class RevAlphabeticSort(TextStat):
    # TODO: Конструктор - это такой же метод, как и остальные. Он подчиняется закону: если не нашли у текущего класса,
    #  идем искать у родительского.
    #  Поэтому если наш конструктор принимает точно такие же параметры, как и его родитель, то мы можем его не писать.
    #  .
    #  Это же касает и других классов (задача 02).
    def __init__(self, file_name):
        super().__init__(file_name=file_name)

    # TODO: в итоге у нас останется только перегруженный метод (их, конечно, может быть несколько).
    def sorting(self):
        return sorted(self.stat.items(), reverse=True)


class QuantitySort(TextStat):

    def __init__(self, file_name):
        super().__init__(file_name=file_name)

    def sorting(self):
        return sorted(self.stat.items(), key=itemgetter(1))


text = TextStat(file_name='python_snippets\\voyna-i-mir.txt.zip')
text.get_file_stat()
text.print_stat()

text = RevAlphabeticSort(file_name='python_snippets\\voyna-i-mir.txt.zip')
text.get_file_stat()
text.print_stat()

text = QuantitySort(file_name='python_snippets\\voyna-i-mir.txt.zip')
text.get_file_stat()
text.print_stat()




# TODO: Абстрактные базовые классы.
#  Давайте сделаем так, чтобы у наш Родительский класс TextStat внутри метода sorting ничего не делал.
def sorting(self):
    pass
# TODO:
#  Определим еще одного наследника, который будет исполнять его поведение "sorted(self.stat.items())".
#  .
#  Тогда сам класс TextStat становится не жизнеспособен: т.е. если мы создадим объект этого класса, то он нам ничего
#  отсортировать не сможет, т.к. его метод sort() - заглушка. В этом случае класс является хранителем общего алгоритма.
#  Т.е. относительно остальных классов наследников он нейтрален (сейчас он больше про сортировку самих букв, а не их
#  количества).
#  .
#  Следующим шагом будет сделать абстрактным родительский класс, у которого sort зашлушка. Что такое абстрактный класс?
#  Абстракный класс - это класс, который имеет хотя бы 1 абстрактный метод. Что такое абстрактным метод?
#  Это метод, который имеет название, но не имеет реализации.
#  .
#  Если класс абстрактный, то создать объект этого класса не представляется возможным. Будет ошибка.
#  .
#  Зачем тогда нужны абстрактные классы?
#  Именно для таких случаев как наш: у нас есть класс-родитель, у которого объявлен метод, но реализации этого метода
#  нет. Классы наследники наследуя этот класс родитель перегружают его метод и по факту дают ему реализацию.
#  .
#  Пример:
from abc import ABC, abstractmethod

# это абстрактный класс, он наследует от ABC (AbstractBaseClass)
class MyAbstractBaseClass(ABC):
    # принимает 2 аргумента
    def __init__(self, x, y):
        self.x = x
        self.y = y

    # этот декоратор показывает, что данные метод абстрактный. И при наследовании его обязательно нужно перегрузить.
    @abstractmethod
    def action(self):
        pass

    # метод который использует action() и возвращает результат
    def get_result(self):
        return self.action()

# Класс-наследник, реализующий Сумму
class SumClass(MyAbstractBaseClass):
    # действие - сумма
    def action(self):
        return self.x + self.y

# Класс-наследник, реализующий Произведение
class MulClass(MyAbstractBaseClass):
    # действие - произведение
    def action(self):
        return self.x * self.y

# Попытка создать объект Абстрактного Класса приведет к ошибке:
# "TypeError: Can't instantiate abstract class MyAbstractBaseClass with abstract methods action"
# MyAbstractBaseClass(x=100, y=500)   # ошибка

# Создаем объекты наследников
object_sum = SumClass(x=100, y=500)
print(object_sum.get_result())          # 600

object_mul = MulClass(x=100, y=500)
print(object_mul.get_result())          # 50000

# TODO: задача: применить АБС внутри своего шаблона.




# После выполнения первого этапа нужно сделать упорядочивание статистики
#  - по частоте по возрастанию
#  - по алфавиту по возрастанию
#  - по алфавиту по убыванию
# Для этого пригодится шаблон проектирование "Шаблонный метод"
#   см https://goo.gl/Vz4828
#   и пример https://gitlab.skillbox.ru/vadim_shandrinov/python_base_snippets/snippets/4


#  можно использовать defaultdict
#       from collections import defaultdict
#  .
#       s = 'mississippi'         # берем строку (итерируемый объект)
#       d = defaultdict(int)      # создаем словарь (подробности ниже)
#       for k in s:               # проходимся по строке и выполняем += 1 для каждой буквы.
#           d[k] += 1
#  .
#       print(d.items())          # [('i', 4), ('p', 2), ('s', 4), ('m', 1)]
#  .
#  Почему код выше работает? Почему на строке "d[k] += 1" при попытке обращение к незаданному ранее ключу
#  не происходит исключение?
#  .
#  Когда мы создаем словарь defaultdict, мы передаем ему ФУНКЦИЮ, которая будет вызываться для инициализации
#  значения, если это значение не найдено в словаре. Поэтому когда мы обращаемся print(d[1000500]) в словаре
#  будет создана пара ключ 1000500 и значение int() (т.е. 0, т.к. int() == 0)
#  .
#  Примеры:
#       d_1 = defaultdict(int)      # {}
#       d_1[100500] += 100          # {100500: 100}
#       x = d_1[123]                # x = 0, d={100500: 100, 123: 0}
#  .
#       d_2 = default(list)         # {}
#       x = d_2['hello']            # x = [], d={'hello': []}
#       d_2['test'].append(123)     # d={'hello': [], 'test': [123]}
#  .
#  Поэтому мы можем удалить проверку условия и смело обращаться к значению по ключу (даже если его еще
#  нет).


#  добавить Метод "форматированный вывод, в виде таблицы", согласно ТЗ.

#  добавить Метод "сортировку по алфавиту"
#  сортировка словаря.
#  Как сортировать? Использовать параметр 'key' у функции sorted.
#  Пусть есть словарь d, скормим его .items() функции sorted() и посмотрим что вышло:
#       d = {'b': 1, 'a': 2, 'c':3}
#       print(sorted(d.items()))            # [('a', 2), ('b', 1), ('c', 3)]
#  .
#  Ф-ция сортировки отсортировала список пар. Каждая пара ключ-значения представлена в виде кортежа.
#  .
#  Когда мы добавляем 'key', мы указываем, что сортировать нужно по какому-то критерию, который должен
#  высчитываться для каждого элемента списка, т.е. для каждой пары.
#  Пример:
#       # импортируем функцию, которая принимает индекс и выдает значение по нему, можно сказать
#       # что itemgetter - это и есть квадратные скобки '[]'
#       from operator import itemgetter
#       .
#       # .items() возвращает пары ключ-значение в виде кортежей. Поэтому здесь происходит сортировка
#       # списка пар ключ-значение. При этом в качестве ключа (критерия) кортировки берется значение,
#       # которое возвращает itemgetter для 1го (не 0го, а 1го) элемента. Т.е. для значения списка.
#       sorted(d.items(), key=itemgetter(1))
#  .
#  itemgetter(1) берет каждую пару и возвращает последний элемент: 2, 1, 3. Получив критерии по которым
#  нужно сортировать элементы, функция sort выполняет сортировку:
#        print(sorted(d.items(), key=itemgetter(1)))           # [('b', 1), ('a', 2), ('c', 3)]
#  .
#  В итоге, мы получаем список из котрежей, где 0ое значение - значения словаря, а 1ое значение - ключ
#  словаря. При этом, этот набор отсортирован по значениям! То, что нужно)
#  .
#  Сортировать словарь - непростая задача. Совсем. Есть более удобный способ, но он еще более сложный,
#  использует словарные включения. Поэтому мы пока остановимся на этом способе.


#  текущий подход сортировки интересный) У него есть 1 изъян: если в словаре будет 2 буквы: А и я, то у нас вместо
#  2х строк в таблице будет 60+ строк и большинство с нулями.
