# -*- coding: utf-8 -*-

# Есть файл с протоколом регистраций пользователей на сайте - registrations.txt
# Каждая строка содержит: ИМЯ ЕМЕЙЛ ВОЗРАСТ, разделенные пробелами
# Например:
# Василий test@test.ru 27
#
# Надо проверить данные из файла, для каждой строки:
# - присутсвуют все три поля
# - поле имени содержит только буквы
# - поле емейл содержит @ и .
# - поле возраст является числом от 10 до 99
#
# В результате проверки нужно сформировать два файла
# - registrations_good.log для правильных данных, записывать строки как есть
# - registrations_bad.log для ошибочных, записывать строку и вид ошибки.
#
# Для валидации строки данных написать метод, который может выкидывать исключения:
# - НЕ присутсвуют все три поля: ValueError
# - поле имени содержит НЕ только буквы: NotNameError (кастомное исключение)
# - поле емейл НЕ содержит @ и .(точку): NotEmailError (кастомное исключение)
# - поле возраст НЕ является числом от 10 до 99: ValueError
# Вызов метода обернуть в try-except.


class NotNameError(Exception):
    pass


class NotEmailError(Exception):
    pass


def check_line(data_line):
    #  если мы хотим разбить строку по пробелам, лучше всегда использовать .split() без параметра.
    #  Да, в таком случае символы перевода строки "\n" будут откинуты. Т.е. сначала будет выполнен .strip(),
    #  а только потом split(' ').
    data_line = data_line.split()

    #  предположим, что в строке оказалось только 2 слова. Как вы думаете, мы дойдем до этой проверки?
    if len(data_line) != 3:
        raise ValueError("Неверное количество параметров")

    person_name, person_email, person_age = data_line

    #  распаковку кортежа лучше делать здесь
    #       Пример:
    #       x, y, z = (1, 2, 3)
    #  .
    #  Либо распаковывать наверху, но тогда нет смысла пытаться поймать "if len(line) != 3:",
    #  т.к. эксперш сработает раньше.

    if not person_name.isalpha():
        raise NotNameError("Указано не верно имя")
    if not ('@' in person_email and '.' in person_email):
        raise NotEmailError("Указан не верно Email")
    if person_age.isalpha():
        raise ValueError("Возраст указан не верно")
    # Info. попытка привести строку к целому само по себе вызове ValueError
    if not (9 < int(person_age) < 100):
        raise ValueError("Возраст не соответствует требованиям")
    return line


#  Нужен ли ValueError при split()?
#   x, y, z, d = 'a a a'.split()
#   Traceback (most recent call last):
#       File "<stdin>", line 1, in <module>
#   ValueError: not enough values to unpack (expected 4, got 3)
#  .
#  Поэтому мы можем сразу приравнять split() к 3 переменным с понятными именами.
#  Или, если хочется явно вызывать этот эксепшн, пусть будет, я совсем не против. Только давайте после него, если
#  он не случился, разобьем list_line на 3 переменных с понятными именами. А то ниже, мы начинаем сравнивать
#  list_line[0] и list_line[1] и list_line[2] и понять что из них за что отвечает будет не просто)


#  если лог файл будет весить 1 ГБ, то мы будем держать в памяти это 1 ГБ.
#  Нам лучше открыть все 3 файла и делать чтение/запись в один момент.
good_list = ""
bad_list = ""
with open('registrations.txt', encoding='utf8') as origin_file, \
        open('registrations_good.log', mode='a', encoding='utf8', buffering=1) as good_file, \
        open('registrations_bad.log', mode='a', encoding='utf8', buffering=1) as bad_file:
    for line in origin_file:
        try:
            # print(checking_line(line=line))
            check_line(data_line=line)
            good_file.write(line)
        except Exception as exc:
            bad_file.write(line)
            print(f'Ошибка в линии "{line[:-1]}" - {exc}')



#  чтобы запись производилась на каждой строке гарантированно, следует добавить "buffering=1" в open().
#  0 - не буферизировать;
#  1 - только 1 строку;
#  N - задать размер буфера в N байт.
#  .
#  Это даст нам гарантии, что в случае падения, или выключения света, последняя записанная строка точно останется.
#  Но это снизит скорость работы, немного. Открытие и закрытие файла, чтобы записать 1 строку - очень сильно снижает
#  скорость работы. В десятки-сотни раз, на больших файлах мы это заметим.
#  .
#  Поэтому выполнить для поледних двух файлов "open(..., buffering=1)" будет то, что надо. Компромисс скорости и надежности.
#  Без него, при внезапном отключении, мы потеряем все что оставалось в буфере. Буфера накапливается, т.к. запись 1
#  большим куском работает быстрее, чем запись из N маленьких кусочков.

#  на самом верху, вместе с "with open('registrations.txt', encoding='utf8') as ff", через запятую:
#  Можно как джун вкладывать друг в друга:
#           with open(...) as f_1:
#               with open(...) as f_2:
#                   line_file_1 = f_1.readline()
#                   line_file_2 = f_2.readline()
#     .
#     А можно использовать более продвинутый синтаксис:
#           with open("1.txt") as f1, open("2.txt") as f2:
#               line_file_1 = f_1.readline()
#               line_file_2 = f_2.readline()